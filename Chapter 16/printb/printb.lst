     1                                  ; printb.asm
     2                                  BITS 64:
     3                                  extern printf
     4                                  section .data				
     5 00000000 B8FFFFFFFFFFFFFF            number1	dq	-72
     6                                  section .bss													
     7                                  section .text									
     8                                  	global main						
     9                                  main:
    10 00000000 55                          push    rbp
    11 00000001 4889E5                      mov     rbp,rsp
    12 00000004 488B3C25[00000000]          mov     rdi, [number1]
    13 0000000C E802000000                  call    printb
    14 00000011 C9                          leave
    15 00000012 C3                          ret
    16                                  
    17                                  printb:
    18                                  section .data
    19 00000008 20                          strspace    db "",32
    20 00000009 3F                          strLen      db  63
    21 0000000A 31                          str1        db "1"
    22 0000000B 30                          str0        db "0"
    23 0000000C 2573                        fmtstr      db "%s"
    24                                  section .bss
    25                                  section .text
    26 00000013 55                          push    rbp
    27 00000014 4889E5                      mov     rbp,rsp
    28                                      
    29 00000017 48B9-                       mov     rcx, strLen
    29 00000019 [0900000000000000] 
    30 00000021 41BC00000000                mov     r12, 0
    31                                  
    32                                  Initialloop:
    33                                      ; check if eighth bit, if yes, print space
    34 00000027 4831C0                      xor     rax,rax      ; clear rax (used in IDIV)
    35 0000002A 31D2                        xor     edx, edx     ; clear edx (used in IDIV, stores the remainder)  
    36 0000002C 66B80800                    mov     ax, 8
    37 00000030 4489E3                      mov     ebx, r12d
    38 00000033 FFC3                        inc     ebx         
    39 00000035 F7FB                        idiv    ebx         ; divide the contents of EDX:EAX by the contents of EBX. 
    40                                                          ; TODO:  Doesnt work. Remainder will also be zero when deviding by 2 and 4 
    41 00000037 83FA00                      cmp     edx, 0x0    ; remainder is stored in edx
    42 0000003A 7535                        jne     Printloop
    43 0000003C 57                          push    rdi
    44 0000003D 6A00                        push    0x0         ; for stack alignment
    45 0000003F 48BF-                       mov	    rdi, fmtstr
    45 00000041 [0C00000000000000] 
    46 00000049 48BE-                       mov     rsi, strspace
    46 0000004B [0800000000000000] 
    47 00000053 B800000000                  mov	    rax,0       ; no floating point
    48 00000058 E8(00000000)                call    printf
    49 0000005D 4883C408                    add     rsp,8       ; skip the 0x0 that was pushed to the stack prior to function call
    50 00000061 5F                          pop     rdi
    51 00000062 4C3B2425[09000000]          cmp     r12, [strLen] ; TODO; I dont think this works?
    52 0000006A 7464                        jz      exit
    53 0000006C 49FFC4                      inc     r12
    54 0000006F EBB6                        jmp     Initialloop
    55                                  
    56                                  Printloop:
    57                                      ; check if bit equals 1, then print 1 else print 0
    58                                      ; test ah, 1<<1
    59 00000071 48D1EF                      shr     rdi, 1  ; does this work?
    60 00000074 732C                        jnc     write1  ; jump no carry (means the bit is zero)
    61 00000076 57                          push    rdi
    62 00000077 6A00                        push    0x0
    63 00000079 48BF-                       mov	    rdi, fmtstr
    63 0000007B [0C00000000000000] 
    64 00000083 48BE-                       mov     rsi, str1   ; TODO; prints 10?
    64 00000085 [0A00000000000000] 
    65 0000008D B800000000                  mov	    rax, 0		
    66 00000092 E8(00000000)                call    printf
    67 00000097 4883C408                    add     rsp,8
    68 0000009B 5F                          pop     rdi
    69 0000009C 5F                          pop     rdi
    70 0000009D 49FFC4                      inc     r12
    71 000000A0 EB85                        jmp     Initialloop
    72                                  
    73                                  write1:
    74 000000A2 57                          push    rdi
    75 000000A3 6A00                        push    0x0
    76 000000A5 48BF-                       mov	    rdi, fmtstr
    76 000000A7 [0C00000000000000] 
    77 000000AF 48BE-                       mov     rsi, str0
    77 000000B1 [0B00000000000000] 
    78 000000B9 B800000000                  mov	    rax, 0		
    79 000000BE E8(00000000)                call    printf
    80 000000C3 4883C408                    add     rsp,8
    81 000000C7 5F                          pop     rdi
    82 000000C8 49FFC4                      inc     r12
    83 000000CB E957FFFFFF                  jmp     Initialloop
    84                                  
    85                                  exit:
    86 000000D0 4889EC                      mov 	rsp,rbp
    87 000000D3 5D                          pop 	rbp
    88 000000D4 C3                          ret
    89                                  
